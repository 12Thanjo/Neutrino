// plugin: steel
// description: a game engine written in neutrino
// author: 12Thanjo

import BABYLON;
import DOM;

species Engine(name, config){
	access name = name;

	// config
	config default {};
	if(config.canvas == null){
		this.canvas = DOM.createElement("canvas", document.body);
		this.canvas.css({
			width: DOM.w,
			height: DOM.h
		});
	}else{
		this.canvas = config.canvas;
	};
	config.fov default 75;
	config.shadowResolution default 2048;
	config.MSAA default 1;
	config.poll default 1000 / 64;
	config.update default @()->{};
	config.render default @()->{};


	//////////////////////////////////////////////////////////////////////



	private.engine = new BABYLON.Engine(this.canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false});
	private.scene = new BABYLON.Scene(private.engine);
	access camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), private.scene);
	private.camera.setTarget(BABYLON.Vector3.Zero());
	private.camera.fov = 2 * 3.14 / 360 * config.fov;
	private.camera.minZ = 0.1;


	
	private.scene.clearColor = new BABYLON.Color3(0.05,0.05,0.06);
	local light = new BABYLON.DirectionalLight("ambient light", new BABYLON.Vector3(-1, -2, -1), private.scene);
	light.position = new BABYLON.Vector3(20, 40, 20);
	light.intensity = 0.6;


	shadowGenerator = new BABYLON.ShadowGenerator(config.shadowResolution, light);
    // shadowGenerator.setDarkness(0.5);
    shadowGenerator.usePoissonSampling = true;


	local sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 512}, private.scene);
	sphere.position.y = 1;
	shadowGenerator.getShadowMap().renderList.push(sphere);
	sphere.receiveShadows = true;
	sphere.material = new BABYLON.StandardMaterial("mat", private.scene);
	sphere.material.diffuseColor = new BABYLON.Color3(0, 0.8, 1);
	define FACTOR = 5;
	sphere.material.emissiveColor = new BABYLON.Color3(0, 0.8 / FACTOR, 1 / FACTOR);

	local new_box = new BABYLON.Mesh.CreateBox("box", 1, private.scene);
	new_box.scaling.set(5, 1, 5);
	new_box.position.y = -1;
	shadowGenerator.getShadowMap().renderList.push(new_box);
	new_box.receiveShadows = true;
	

	macro "post processing";
	this.pipeline.MSAA = config.MSAA;


	private.update = new time.AdvancedInterval(config.poll, @()->{
		config.update();
	});
	private.update.start();


	macro "performance";
	private.engine.runRenderLoop(@()->{
		calc_performance();
		config.render();
	   	private.scene.render();
	});
};
plugin.Engine = Engine;